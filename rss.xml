<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>七八老酒</title>
        <link>https://www.ducksoso.com/</link>
        <description>MemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。</description>
        <generator>Hugo 0.74.3 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>zzj13865@gmail.com (七八老酒)</managingEditor>
        
        
            <webMaster>zzj13865@gmail.com (七八老酒)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Wed, 27 Jan 2021 11:43:10 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://www.ducksoso.com/rss.xml" />
        
        
            <item>
                <title>Go注释的魔力</title>
                <link>https://www.ducksoso.com/posts/golang/go%E6%B3%A8%E9%87%8A%E7%9A%84%E9%AD%94%E5%8A%9B/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/golang/go%E6%B3%A8%E9%87%8A%E7%9A%84%E9%AD%94%E5%8A%9B/</guid>
                <pubDate>Tue, 26 Jan 2021 09:06:03 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go-注释语法&#34;&gt;Go 注释语法&lt;/h1&gt;
&lt;p&gt;继承于 C 语言的语法，Go 支持常见的单行注释和多行注释，使用 &lt;code&gt;// &lt;/code&gt;和&lt;code&gt; /* ... */&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 行尾的所有内容都是注释

var foo int;  // 注释可以从任一行中的任何地方开始

/*

多行注释

*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尽管Go编译器会忽略注释的内容，但这并不意味着Go工具集会完全忽略注释的内容。本文将会介绍一些特殊格式的注释的使用。&lt;/p&gt;
&lt;h2 id=&#34;1godoc文档文本&#34;&gt;1、godoc文档文本&lt;/h2&gt;
&lt;p&gt;Go 中最常见的「神奇」注释形式可能是对 Go 内置文档工具 godoc 的注释。godoc 的工作原理是扫描所有 .go 的数据。在一个包中的文件 (忽略任何 _test.go 文件) 中查找声明之前的注释 (没有任何中间代码或空行)。godoc 将使用注释的文本来形成包的文档。&lt;/p&gt;
&lt;p&gt;例如，要记录一个函数，只需在其声明之前的行上放置一行或多行注释：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Foo&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;将是&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;给定的字符串&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;如果字符串不能被&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;赋值&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 返回一个 error
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 &lt;strong&gt;导出&lt;/strong&gt; 和 **包级 **类型、函数、方法、变量或常量声明之前，可以使用相同的注释样式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;objects&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Object是一个通用的东西
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Bar将是bar的Object，如果不是则返回error
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// List包含所有当前注册的Object
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;List&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Object&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// MaxCount确定允许的最大对象数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MaxCount&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;50&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;因为只导出包级别的注释，所以开发人员可以自由地在方法 / 函数体中使用注释，而不必担心注释会被不小心添加到公共文档中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;godoc&lt;/code&gt;也提供一种通过解析包申明前的注释来生成包级别的文档的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 包对象完成基本对象的叙述
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;objects&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;需要注意的是 godoc 在生成包的索引（请看示例  &lt;a href=&#34;https://golang.org/pkg/&#34;&gt;https://golang.org/pkg/&lt;/a&gt; ）的时候使用第一句包文档注释，因此一定要写相应的包描述。&lt;/p&gt;
&lt;p&gt;如你所见，注释产生一种简单的方法来为开发者和使用者提供文档，而不需要复杂的语法和额外的文档文件。&lt;/p&gt;
&lt;h2 id=&#34;2构建约束&#34;&gt;2、构建约束&lt;/h2&gt;
&lt;p&gt;Go 语言中注释的第二个特殊用途是构建约束。&lt;/p&gt;
&lt;p&gt;Go 作为一种编程语言的关键特性是它支持各种操作系统和体系结构。通常情况下，相同的代码可以用于多个平台。但是在某些情况下，特定于操作系统或体系结构的代码应该只用于特定的目标。标准的 go build 工具可以通过理解以操作系统名称和 / 或体系结构结尾的程序应该只用于匹配这些标记的目标来处理某些情况。例如，一个名为 foo_linux.go 的文件，将只会被 Linux 系统编译。 foo_amd64.go 用于 AMD64 架构，foo_windows_amd64.go 用于运行在 AMD64 架构上的 64 位 Windows 系统。&lt;/p&gt;
&lt;p&gt;然而，这些命名约束在更复杂的情况下会失败，例如当同一代码可以用于多个 (但不是所有) 操作系统时。在这些情况下，Go 有构建约束的概念 —— 在编译 Go 程序时，go build 将读取经过特殊设计的注释，以确定要引用哪些文件。&lt;/p&gt;
&lt;p&gt;构建约束的注释遵循以下规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以前缀&lt;code&gt;+build&lt;/code&gt;开始，后跟一个或多个空格&lt;/li&gt;
&lt;li&gt;位于文件顶部在包声明之前&lt;/li&gt;
&lt;li&gt;在它和包声明之间至少有一个空行，以防止它被视为包文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而不是将文件命名为 &lt;code&gt;foo_linux.go&lt;/code&gt;。我们可以把下面的注释放在文件&lt;code&gt;foo.go&lt;/code&gt;的开头：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// +build linux
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而，当引用多个体系结构和 / 或操作系统时，构建约束的威力就显现出来了。Go 为组合构建约束制定了以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 ! 开头的构建标记是无效的&lt;/li&gt;
&lt;li&gt;用空格分隔的构建标记在逻辑上是或&lt;/li&gt;
&lt;li&gt;以逗号分隔的构建标记在逻辑上是和&lt;/li&gt;
&lt;li&gt;在多行上构建约束是逻辑和&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上面的规则，下面的约束将把文件限制为 Linux 或 Darwin(MacOS):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// +build linux darwin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而这个约束同时需要 Windows 和 i386&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// +build windows,386
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的约束也可以写在下面的两行中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// +build windows
// +build 386
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;使用 ! 进行编译区分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个文件中一个是hash tag，一个是 int tag，在编译的时候通过&lt;code&gt;go build -tags xxx&lt;/code&gt;指定哪些不被编译，否则只有不带 ! 的tag都会被编译进包。&lt;/p&gt;
&lt;p&gt;display_hash.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// +build hash !display_alternatives
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 上面
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DisplayName&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DisplayName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;MakeDisplayName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DispalyName&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;DispalyName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;display_int.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// +build int
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;encoding/hex&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;encoding/binary&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DisplayName&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DisplayName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;MakeDisplayName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DisplayName&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DecodeString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;decode hex string failed. cause: %v\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;data: %v\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;binary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;BigEndian&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;DisplayName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编译&lt;code&gt;display_int.go&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译执行过程&lt;code&gt;go build -tags &amp;quot;display_alternatives int&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译&lt;code&gt;display_hash.go&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译执行过程&lt;code&gt;go build -tags hash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里面有个问题，不传递-tags，为什么也会编译，因为在 go/build/build.go中的match方法中有这么一句：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HasPrefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// negation
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctxt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:])&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;也就是说，只要有!（不能只是!），tag不在BuildTags中时，总是会编译。&lt;/p&gt;
&lt;p&gt;回到刚才的 tag，hash 和 int，在执行&lt;code&gt;go build -tags &amp;quot;display_alternatives int&amp;quot;&lt;/code&gt;，会导致 ! 无效，所以就不会执行 hash的代码。&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt; &lt;strong&gt;构建约束以一行&lt;code&gt;+build&lt;/code&gt;开始的注释&lt;/strong&gt; ，在&lt;code&gt;+build&lt;/code&gt;之后列出了一些条件，在这些条件成立时，该文件应包含在编译的包中&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;除了指定操作系统和体系结构之外，构建约束可以通过 ignore 标记的常见用法来完全忽略文件（任何不匹配有效架构或操作系统的文本是可以工作的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// +build ignore
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;应该注意的是，这些构建约束（以及前面提到的命名约定）也适用于测试文件，因此可以以类似的方式执行特定于体系结构 / 操作系统的测试。&lt;/p&gt;
&lt;h4 id=&#34;主要解决问题&#34;&gt;主要解决问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;go的同一包下面，如果方法同名是会报错的，于是使用构建约束解决了代码解耦问题。&lt;/li&gt;
&lt;li&gt;指定哪些文件能够被编译，以及在编译的时机，主要是通过&lt;code&gt;go build -tags xxx&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3生成代码&#34;&gt;3、生成代码&lt;/h2&gt;
&lt;p&gt;Go 语言注释的另一个有趣的用法是通过 &lt;code&gt;go generate&lt;/code&gt; 命令生成代码。 &lt;code&gt;go generate&lt;/code&gt; 是 Go 语言标准工具包的一部分，它通过运行用户指定的外部命令以编程方式生成源 (或其他) 文件。&lt;code&gt;go generate&lt;/code&gt; 的工作方式是扫描 &lt;code&gt;.go&lt;/code&gt; 程序，寻找其中包含要运行的命令的特殊注释，然后执行它们。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;code&gt;go generate&lt;/code&gt; 查找以 &lt;code&gt;go:generate&lt;/code&gt; 开头的注释（注释标记和文本开始之间没有空格），如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//go:generate &amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与构建约束不同，&lt;code&gt;go:generate&lt;/code&gt;注释可以位于&lt;code&gt;.go&lt;/code&gt;源文件中的任何位置（尽管典型的Go语言习惯用法是将它们放在文件的开头）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;go:generate&lt;/code&gt;的常见用法是通过这里提供的&lt;code&gt;stringer&lt;/code&gt;工具提供人类可读的常量值。&lt;code&gt;stringer&lt;/code&gt;文档提供了下面的示例来解释它的操作。给定一个自定义类型，&lt;code&gt;Pill&lt;/code&gt;，枚举常量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Pill&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;Placebo&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Pill&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;iota&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;Aspirin&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;Ibuprofen&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;Paracetamol&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;Acetaminophen&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Paracetamol&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行命令&lt;code&gt;stringer -type Pill&lt;/code&gt;将会创建一个新的源文件&lt;code&gt;pill_string.go&lt;/code&gt;，它提供了以下方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Pill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;例如，它允许打印常量的名称：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;pill type: %s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但是需要记住包中每个适用类型的正确命令和参数可能很复杂，因此我们可以将以下注释添加到包的&lt;code&gt;.go&lt;/code&gt;文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//go:generate stringer -type=Pill
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后运行&lt;code&gt;go:generate&lt;/code&gt;将会触发&lt;code&gt;stringer&lt;/code&gt;的调用，适用正确的参数来创建我们的&lt;code&gt;Pill&lt;/code&gt;字符串方法。在这种情况下，我们可以看到&lt;code&gt;stringer&lt;/code&gt;和&lt;code&gt;go generate&lt;/code&gt;对程序员带来的巨大好处，尤其是在包中有多个自定义类型的情况下。&lt;/p&gt;
&lt;h2 id=&#34;4cgo&#34;&gt;4、Cgo&lt;/h2&gt;
&lt;p&gt;Go 语言中注释的一个特殊用法是 C 语言集成工具 Cgo。 Cgo 允许 Go 程序直接调用 C 语言代码，允许在 Go 中重用已建立的 C 语言库。要在 Go 程序中使用 Cgo，首先要导入伪包「C」。一旦导入，Go 程序就可以引用像 &lt;code&gt;C.size_t&lt;/code&gt; 这样的原生 C 类型和 &lt;code&gt;C.putchar() &lt;/code&gt;这样的函数。&lt;/p&gt;
&lt;p&gt;然而，C 语言编程的某些方面是很难转换的。为了处理这些问题，Cgo 特别使用了&lt;code&gt; import 「C」&lt;/code&gt; 语句之前的注释（在 Cgo 术语中称为 序言 ）来提供各种 C 语言特定的配置项。&lt;/p&gt;
&lt;p&gt;其中一项是 &lt;code&gt;#include&lt;/code&gt; 指令。几乎每个 C 程序都需要&lt;code&gt;#include&lt;/code&gt;指令来指示头文件的位置。Go 语言没有任何本地对应的命令 (&lt;code&gt;import&lt;/code&gt; 在包上工作，而不是头文件)，所以 Cgo 解析序言中的&lt;code&gt;#include&lt;/code&gt;语句。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// #include &amp;lt;stdio.h&amp;gt;
// #include &amp;lt;errno.h&amp;gt;
import &amp;quot;C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;序言部分的注释不仅仅限于&lt;code&gt;#include&lt;/code&gt;语句，实际上，import 语句之前的任何注释都将视为标准的C代码，然后可以通过 &lt;code&gt;C&lt;/code&gt; 包进行引用。比如，序言：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// #include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// static void myprint(char *s) {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//    printf(&amp;#34;%s\n&amp;#34;, s)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后我们可以在Go中引用这个新定义的C函数，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;myprint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;最后，为了处理编译器和类似的选项，Cgo引入来&lt;code&gt;#Cgo&lt;/code&gt;指令，该指令可用于设置环境变量、编译器标记和运行 &lt;code&gt;pkg-config&lt;/code&gt; 命令，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// #cgo CFLAGS: -DPNG_DEBUG=1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #cgo amd64 386 CFLAGS: -DX86=1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #cgo LDFLAGS: -lpng
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #cgo pkg-config: png cairo
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// #include &amp;lt;png.h&amp;gt;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;所有这些序言的定义帮助适用 &lt;code&gt;Cgo&lt;/code&gt; 的程序与 go 构建工具无缝集成，而不需要额外复杂的创建文件或其他脚本。&lt;/p&gt;
&lt;h2 id=&#34;5编译指示&#34;&gt;5、编译指示&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;官方文档：https://golang.org/cmd/compile/#hdr-Compiler_Directives&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;形如&lt;font color=red&gt; &lt;code&gt;//go:&lt;/code&gt; &lt;/font&gt;就是Go语言的编译指示的实现方式。相信看过 Go SDK 的同学并不陌生，经常能在代码函数声明的上一行看到这样的写法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器源码 里可以看到全部的指示，但是要注意，&lt;code&gt;//go:&lt;/code&gt;是连续的，&lt;code&gt;//&lt;/code&gt; 和 &lt;code&gt;go&lt;/code&gt; 之间并没有空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;常用指示详解&#34;&gt;常用指示详解&lt;/h3&gt;
&lt;h4 id=&#34;font-colorredgonoinlinefont&#34;&gt;&lt;font color=red&gt;&lt;code&gt;//go:noinline&lt;/code&gt;&lt;/font&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;noinline&lt;/code&gt;顾名思义，不要内联。&lt;/strong&gt;&lt;/p&gt;
&lt;h6 id=&#34;inline内联inline是在编译期间发生的将函数调用处替换为被调用函数主体的一种编译器优化手段&#34;&gt;&lt;code&gt;Inline内联：Inline，是在编译期间发生的，将函数调用处替换为被调用函数主体的一种编译器优化手段。&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;Inline&lt;/code&gt; 有一些优势，同时也有一些问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少函数调用的开销，提供执行速度。&lt;/li&gt;
&lt;li&gt;复制后的更大函数体为其他编译优化带来可能性，如：过程间优化&lt;/li&gt;
&lt;li&gt;消除分支，并改善空间局部性和指令顺序性，同样可以提高性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;劣势：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码复制带来的空间增长&lt;/li&gt;
&lt;li&gt;如果有大量重复代码，反而会降低缓存命中率，尤其对CPU缓存是致命的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，实际使用中，对于是否使用内联，要谨慎考虑，并做好平衡，以使它发挥最大的作用。简单来说，对于短小而且工作较少的函数，使用内联是有效益的。&lt;/p&gt;
&lt;h5 id=&#34;内联的例子&#34;&gt;内联的例子&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;appendStr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;new &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;word&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行 &lt;font color=red&gt;&lt;code&gt;GOOS=linux GOARCH=386 go tool compile -S main.go &amp;gt; main.S&lt;/code&gt;&lt;/font&gt;
我截取有区别的部分展出它编译后的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0x0015 00021 (main.go:4)    LEAL    &amp;quot;&amp;quot;..autotmp_3+28(SP), AX
    0x0019 00025 (main.go:4)    PCDATA    $2, $0
    0x0019 00025 (main.go:4)    MOVL    AX, (SP)
    0x001c 00028 (main.go:4)    PCDATA    $2, $1
    0x001c 00028 (main.go:4)    LEAL    go.string.&amp;quot;new &amp;quot;(SB), AX
    0x0022 00034 (main.go:4)    PCDATA    $2, $0
    0x0022 00034 (main.go:4)    MOVL    AX, 4(SP)
    0x0026 00038 (main.go:4)    MOVL    $4, 8(SP)
    0x002e 00046 (main.go:4)    PCDATA    $2, $1
    0x002e 00046 (main.go:4)    LEAL    go.string.&amp;quot;hello&amp;quot;(SB), AX
    0x0034 00052 (main.go:4)    PCDATA    $2, $0
    0x0034 00052 (main.go:4)    MOVL    AX, 12(SP)
    0x0038 00056 (main.go:4)    MOVL    $5, 16(SP)
    0x0040 00064 (main.go:4)    CALL    runtime.concatstring2(SB)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，它并没有调用 &lt;code&gt;appendStr&lt;/code&gt; 函数，而是直接把这个函数体的功能内联了。&lt;/p&gt;
&lt;p&gt;那么话说回来，如果你不想被内联，怎么办呢？此时就该使用 &lt;code&gt;go//:noinline&lt;/code&gt; 了，像下面这样写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//go:noinline
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;appendStr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;new &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;word&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编译后是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0x0015 00021 (main.go:4)    LEAL    go.string.&amp;quot;hello&amp;quot;(SB), AX
    0x001b 00027 (main.go:4)    PCDATA    $2, $0
    0x001b 00027 (main.go:4)    MOVL    AX, (SP)
    0x001e 00030 (main.go:4)    MOVL    $5, 4(SP)
    0x0026 00038 (main.go:4)    CALL    &amp;quot;&amp;quot;.appendStr(SB)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时编译器就不会做内联，而是直接调用 &lt;code&gt;appendStr&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h4 id=&#34;font-colorredgonosplitfont&#34;&gt;&lt;font color=red&gt;&lt;code&gt;//go:nosplit&lt;/code&gt;&lt;/font&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;nosplit&lt;/code&gt; 的作用是：跳过栈溢出检测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈溢出是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正是因为一个 &lt;code&gt;Goroutine&lt;/code&gt; 的起始栈大小是有限制的，且比较小的，才可以做到支持并发很多 &lt;code&gt;Goroutine&lt;/code&gt;，并高效调度。
stack.go 源码中可以看到，&lt;code&gt;_StackMin&lt;/code&gt; 是 2048 字节，也就是 2k，它不是一成不变的，当不够用时，它会动态地增长。
那么，必然有一个检测的机制，来保证可以及时地知道栈不够用了，然后再去增长。
回到话题，&lt;code&gt;nosplit&lt;/code&gt; 就是将这个跳过这个机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优劣&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然地，不执行栈溢出检查，可以提高性能，但同时也有可能发生 &lt;code&gt;stack overflow&lt;/code&gt; 而导致编译失败。&lt;/p&gt;
&lt;h4 id=&#34;font-colorredgonoescapefont&#34;&gt;&lt;font color=red&gt;&lt;code&gt;//go:noescape&lt;/code&gt;&lt;/font&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;noescape&lt;/code&gt; 的作用是：禁止逃逸，而且它必须指示一个只有声明没有主体的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逃逸是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Go 相比 C、C++ 是内存更为安全的语言，主要一个点就体现在它可以自动地将超出自身生命周期的变量，从函数栈转移到堆中，逃逸就是指这种行为。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逃逸分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;优劣&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最显而易见的好处是，GC 压力变小了。
因为它已经告诉编译器，下面的函数无论如何都不会逃逸，那么当函数返回时，其中的资源也会一并都被销毁。
不过，这么做代表会绕过编译器的逃逸检查，一旦进入运行时，就有可能导致严重的错误及后果。&lt;/p&gt;
&lt;h4 id=&#34;font-colorredgonoracefont&#34;&gt;&lt;font color=red&gt;&lt;code&gt;//go:norace&lt;/code&gt;&lt;/font&gt;&lt;/h4&gt;
&lt;p&gt;norace 的作用是：跳过竞态检测
我们知道，在多线程程序中，难免会出现数据竞争，正常情况下，当编译器检测到有数据竞争，就会给出提示。如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行 &lt;code&gt;go run -race main.go&lt;/code&gt; 利用&lt;code&gt; -race&lt;/code&gt; 来使编译器报告数据竞争问题。你会看到：&lt;/p&gt;
&lt;p&gt;说明两个 &lt;code&gt;goroutine&lt;/code&gt; 执行的 &lt;code&gt;add()&lt;/code&gt; 在竞争。&lt;/p&gt;
&lt;p&gt;绝大多数情况下，无需在编程时使用 &lt;code&gt;//go: Go&lt;/code&gt; 语言的编译器指示，除非你确认你的程序的性能瓶颈在编译器上，否则你都应该先去关心其他更可能出现瓶颈的事情。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;这里一共提及5种注释的含义&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://www.ducksoso.com/categories/go/">Go</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://www.ducksoso.com/tags/go%E6%B3%A8%E9%87%8A/">Go注释</category>
                                
                            
                                
                                
                                
                                    <category domain="https://www.ducksoso.com/tags/%E6%9E%84%E5%BB%BA%E7%BA%A6%E6%9D%9F/">构建约束</category>
                                
                            
                                
                                
                                
                                    <category domain="https://www.ducksoso.com/tags/%E7%BC%96%E8%AF%91%E6%8C%87%E7%A4%BA/">编译指示</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Go Tools</title>
                <link>https://www.ducksoso.com/posts/golang/go-tools/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/golang/go-tools/</guid>
                <pubDate>Mon, 25 Jan 2021 20:19:45 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h1 id=&#34;go-build&#34;&gt;go build&lt;/h1&gt;
&lt;h2 id=&#34;1基本用法&#34;&gt;1、基本用法&lt;/h2&gt;
&lt;h2 id=&#34;2构建约束&#34;&gt;2、构建约束&lt;/h2&gt;
&lt;h1 id=&#34;go-install&#34;&gt;go install&lt;/h1&gt;
&lt;h1 id=&#34;go-run&#34;&gt;go run&lt;/h1&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>作息时间表</title>
                <link>https://www.ducksoso.com/posts/life/%E4%BD%9C%E6%81%AF%E6%97%B6%E9%97%B4%E8%A1%A8/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/life/%E4%BD%9C%E6%81%AF%E6%97%B6%E9%97%B4%E8%A1%A8/</guid>
                <pubDate>Sun, 17 Jan 2021 20:34:38 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;作息时间表&#34;&gt;作息时间表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;对于健康来说，年轻并不是资本，因为如果你肆意的挥霍，30岁之后都会一一报偿回来，监督自己和他一起养成好作息吧，不熬夜、不暴饮暴食、不吸烟、多运动，这才是健康生活的真谛哟！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;700-起床&#34;&gt;&lt;strong&gt;7:00 起床&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;7:00是起床的最佳时刻，身体已经准备好一切了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打开台灯，告诉身体的每一个部分，尽快从睡眠中醒来，调整好生物钟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;醒来后需要一杯温开水，水是身体内成千上万化学反应得以进行的必需物质，饮水帮助每一个缺水的细胞都重新活力四射。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;720-800-吃早饭&#34;&gt;&lt;strong&gt;7:20-8:00 吃早饭&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;早饭必须吃，这没有什么好解释的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一上午专注的工作学习需要正常的血糖来维持，因此为自己也为他准备一份丰盛的早餐是必须的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;830-900-避免运动&#34;&gt;&lt;strong&gt;8:30-9:00 避免运动&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;清晨并不是运动的最佳时间，因为此时免疫系统功能最弱，你可以选择步行上班，那却是很健康的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;900-1030-安排最困难的工作&#34;&gt;&lt;strong&gt;9:00-10:30&lt;/strong&gt; 安排最困难的工作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;学习工作的最佳时间，头脑最清醒，思路最清晰的时间段。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;千万不要把宝贵的时间用来看电影、逛淘宝。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1030-眼睛需要休息一会儿&#34;&gt;&lt;strong&gt;10:30&lt;/strong&gt; 眼睛需要休息一会儿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;看看窗外，眼睛很累了，需要休息一会儿。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1100-吃点水果&#34;&gt;&lt;strong&gt;11:00 吃点水果&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;上午吃水果是金，水果的营养可以充分的被身体采纳。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时血糖可能会有一些下降，让身体无法专心工作，水果是最佳的加餐食物。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1200-1230-午餐别忘了多吃豆类&#34;&gt;&lt;strong&gt;12:00-12:30 午餐别忘了多吃豆类&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;豆类是很棒的食物，富含膳食纤维和蛋白质，别光顾着吃肉，多吃些豆类食物。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1300-1400-小睡一会儿&#34;&gt;&lt;strong&gt;13:00-14:00 小睡一会儿&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;30分钟的午休会让你精力充沛，更重要的是会更健康。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逛淘宝、聊天并不能帮你缓解困意，反而会在停止后更加困倦，最好的休息方式当然还是小睡一会儿。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1600-一杯酸奶&#34;&gt;&lt;strong&gt;16:00 一杯酸奶&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;酸奶是零负担的健康零食。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;酸奶可以保持血糖稳定的同时，还能帮助肠道消化，而且有研究发现，喝酸奶对心血管系统的健康很不错。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1900-最佳锻炼时间&#34;&gt;&lt;strong&gt;19:00&lt;/strong&gt; 最佳锻炼时间&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;晚餐后稍作休息，可以开始健身了。你可以选择相对温和的快步走，也可以慢跑或游泳，根据个人需求进行体育锻炼，既可以消耗晚餐热量，也能够轻松瘦身。最关键的不仅是你的运动时间超过40分钟，而且需要长期坚持。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2000-看电视或看书&#34;&gt;&lt;strong&gt;20:00&lt;/strong&gt; 看电视或看书&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;工作太辛苦就看会儿电视或书籍杂志，反而会让你更轻松随意。如果希望自己学习更多的东西，不如看些专业的书籍，这对你的个人积累很重要。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2200-洗个热水澡&#34;&gt;&lt;strong&gt;22:00&lt;/strong&gt; 洗个热水澡&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;帮助身体降温和清洁，有利于放松和睡眠。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2230-上床睡觉&#34;&gt;&lt;strong&gt;22:30&lt;/strong&gt; 上床睡觉&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为了保证充足的睡眠和身体各个系统，是时候该睡觉了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;试图颠倒生物钟的作息，会为身体留下抹不掉痕迹，35岁之后你会明白什么叫“病找人”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;保证每天早上7点起床，中午1点到2点休息，晚上十一点半睡觉的整体规律。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Hello World</title>
                <link>https://www.ducksoso.com/posts/hello-world/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/hello-world/</guid>
                <pubDate>Thu, 14 Jan 2021 16:32:46 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description></description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>网络基础概念</title>
                <link>https://www.ducksoso.com/posts/network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
                <pubDate>Thu, 17 Sep 2020 16:48:25 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;为什么-tcpip-协议会拆分数据&#34;&gt;为什么 TCP/IP 协议会拆分数据&lt;/h2&gt;
&lt;p&gt;当应用层协议使用 TCP/IP 协议传输数据时，TCP/IP 协议簇可能会将应用层发送的数据分成多个包依次发送，而数据的接收方收到的数据可能是分段的或者拼接的，所以它需要对接收的数据进行拆分或者重组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP 协议会分片传输过大的数据包（Packet）避免物理设备的限制；&lt;/li&gt;
&lt;li&gt;TCP 协议会分段传输过大的数据段（Segment）保证传输的性能；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最大传输单元&#34;&gt;最大传输单元&lt;/h3&gt;
&lt;p&gt;IP 协议是用于传输数据包的协议，作为网络层协议，它能提供数据的路由和寻址功能，让数据通过网络到达目的地。不同设备之间传输数据前，需要先确定一个 IP 数据包的大小上限，即最大传输单元（Maximum transmission unit，即 MTU），MTU 是 IP 数据包能够传输的数据上限。&lt;/p&gt;
&lt;p&gt;MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。每一个物理设备都有自己的 MTU，两个主机之间的 MTU 依赖于底层的网络能力，它由整个链路上 MTU 最小的物理设备决定，如下图所示，网络路径的 MTU 由 MTU 最小的红色物理设备决定，即 1000：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/mtu-discovery.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;​								路径最大传输单元发现&lt;/p&gt;
&lt;p&gt;路径最大传输单元发现（Path MTU Discovery，PMTUD）是用来确定两个主机传输路径 MTU 的机制，它的工作原理如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向目的主机发送 IP 头中 DF 控制位为 1 的数据包，DF 是不分片（Don’t Fragment，DF）的缩写；&lt;/li&gt;
&lt;li&gt;路径上的网络设备根据数据包的大小和自己的 MTU 做出不同的决定：
&lt;ol&gt;
&lt;li&gt;如果数据包大于设备的 MTU，就会丢弃数据包并发回一个包含该设备 MTU 的 ICMP 消息；&lt;/li&gt;
&lt;li&gt;如果数据包小于设备的 MTU，就会继续向目的主机传递数据包；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;源主机收到 ICMP 消息后，会不断使用新的 MTU 发送 IP 数据包，直到 IP 数据包达到目的主机；&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;ICMP 是互联网控制消息协议（Internet Control Message Protocol，ICMP），它能在 IP 主机之间传递控制消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以太网对数据帧的限制一般都是 1500 字节，在一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输。&lt;/p&gt;
&lt;p&gt;IP 协议数据分片对传输层协议是透明的，假设我们使用 UDP 协议传输 2000 字节的数据，加上 UDP 8 字节的协议头，IP 协议需要传输 2008 字节的数据。如下图所示，当 IP 协议发现待传输的数据大于 1480 字节，就会将数据分成下面的两个数据包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/udp-ip-packet.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;​								分片传输的 UDP 数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;20 字节 IP 协议头 + 8 字节 UDP 协议头 + 1472 字节数据；&lt;/li&gt;
&lt;li&gt;20 字节 IP 协议头 + 528 字节数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据的接收方在收到数据包时会对分片的数据进行重组，不过因为第二个数据包中不包含 UDP 协议的相关信息，一旦发生丢包，整个 UDP 数据报就无法重新拼装。如果 UDP 数据报需要传输的数据过多，那么 IP 协议就会大量分片，增加了不稳定性。&lt;/p&gt;
&lt;p&gt;如果 IP 协议没有数据包大小的限制，那么上层可以以消息为单位传输数据，自然就不存在分片和组装的需求，不过因为物理设备的 MTU 限制，想要保证数据传输的可靠性和稳定性还需要传输层的配合。&lt;/p&gt;
&lt;h3 id=&#34;最大分段大小&#34;&gt;最大分段大小&lt;/h3&gt;
&lt;p&gt;TCP 协议是面向字节流的协议，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机发送，应用层交给 TCP 协议发送的数据可能会被拆分到多个数据段中。&lt;/p&gt;
&lt;p&gt;TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节；不过如果通信双方没有指定 MSS 的话，在默认情况下 MSS 的大小是 536 字节。&lt;/p&gt;
&lt;p&gt;IP 协议的 MTU 是物理设备上的限制，它限制了路径能够发送数据包的上限，而 TCP 协议的 MSS 是操作系统内核层面的限制，通信双方会在三次握手&lt;a href=&#34;https://draveness.me/whys-the-design-tcp-segment-ip-packet/#fn:11&#34;&gt;11&lt;/a&gt;时确定这次连接的 MSS。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据进行拆分，构成多个数据段。&lt;/p&gt;
&lt;p&gt;需要注意的是，IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包（Package）为单位组织数据，而 TCP 协议以数据段（Segment）为单位组织数据。&lt;/p&gt;
&lt;p&gt;如下图所示，如果 TCP 连接的 MSS 是 1460 字节，应用层想要通过 TCP 协议传输 2000 字节的数据，那么 TCP 协议会根据 MSS 将 2000 字节的数据拆分到两个数据段中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/tcp-ip-packet.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;​										分段传输的 TCP 数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;20 字节 IP 头 + 20 字节 TCP 头 + 1460 字节数据；&lt;/li&gt;
&lt;li&gt;20 字节 IP 头 + 20 字节 TCP 头 + 540 字节数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从应用层的角度来看，两个数据段中 2000 字节的数据构成了发送方想要发送的消息，但是 TCP 协议是面向字节流的，向协议写入的数据会以流的形式传递到对端。&lt;/p&gt;
&lt;p&gt;TCP 协议为了保证可靠性，会通过 IP 协议的 MTU 计算出 MSS 并根据 MSS 分段避免 IP 协议对数据包进行分片。因为 IP 协议对数据包的分片对上层是透明的，如果协议不根据 MTU 做一些限制，那么 IP 协议的分片会导致部分数据包失去传输层协议头，一旦数据包发生丢失就只能丢弃全部数据。&lt;/p&gt;
&lt;p&gt;我们可以通过一个例子分析 MSS 存在的必要性。如下图所示，假设 TCP 协议中不存在 MSS 的概念，因为每个数据段的大小没有上限，当 TCP 协议交给 IP 层发送两个 1600 字节（包括 IP 和 TCP 协议头）的数据包时，由于物理设备的限制，IP 协议的路径 MTU 为 1500 字节，所以 IP 协议会对数据包分片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/tcp-ip-packet-with-ip-fragmentation.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;​									分片传输的 TCP 数据&lt;/p&gt;
&lt;p&gt;四个数据包中只有两个会包含 TCP 协议头，即控制位、序列号等信息，剩下的两个数据包中不包含任何信息。当 IP 协议传输数据丢包时，TCP 协议的接收方没有办法对数据包进行重组，所以整个 TCP 数据段都需要重传，带来了更多额外的重传和重组开销。&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;数据拆分的根本原因说到底还是物理设备的限制，不过每一层协议都受限于下一层协议做出的决定，并依赖下层协议重新决定设计和实现的方法。虽然 TCP/IP 协议在传输数据时都需要对数据进行拆分，但是它们做出拆分数据的设计基于不同的上下文，也有着不同的目的，我们在这里总结一下两个网络协议做出类似决定的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP 协议拆分数据是因为物理设备的限制，一次能够传输的数据由路径上 MTU 最小的设备决定，一旦 IP 协议传输的数据包超过 MTU 的限制就会发生丢包，所以我们需要通过路径 MTU 发现获取传输路径上的 MTU 限制；&lt;/li&gt;
&lt;li&gt;TCP 协议拆分数据是为了保证传输的可靠性和顺序，作为可靠的传输协议，为了保证数据的传输顺序，它需要为每一个数据段增加包含序列号的 TCP 协议头，如果数据段大小超过了 IP 协议的 MTU 限制， 就会带来更多额外的重传和重组开销，影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;名词解释&#34;&gt;名词解释&lt;/h2&gt;
&lt;p&gt;报文、报文段、分组、包、数据报、帧、数据流的概念区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.报文(message)&lt;/strong&gt;
我们将位于应用层的信息分组称为报文。报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.报文段(segment)&lt;/strong&gt;
通常是指起始点和目的地都是传输层的信息单元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.分组/包(packet)&lt;/strong&gt;
分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。它的起始和目的地是网络层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.数据报(datagram)&lt;/strong&gt;
面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。通常是指起始点和目的地都使用无连接网络服务的的网络层的信息单元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.帧(frame)&lt;/strong&gt;
帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。它的起始点和目的点都是数据链路层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.数据单元（data unit）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指许多信息单元。常用的数据单元有服务数据单元（SDU）、协议数据单元（PDU）。
SDU是在同一机器上的两层之间传送信息。PDU是发送机器上每层的信息发送到接收机器上的相应层（同等层间交流用的）。&lt;/p&gt;
&lt;h4 id=&#34;名词与tcpip协议对应关系&#34;&gt;名词与TCP/IP协议对应关系&lt;/h4&gt;
&lt;p&gt;应用层——报文（消息）&lt;/p&gt;
&lt;p&gt;传输层——数据段/报文段(segment) (注：TCP叫TCP报文段，UDP叫UDP数据报,也有人叫UDP段)&lt;/p&gt;
&lt;p&gt;网络层——分组、数据包（packet）&lt;/p&gt;
&lt;p&gt;链路层——帧（frame）&lt;/p&gt;
&lt;p&gt;物理层——P-PDU（bit）&lt;/p&gt;
&lt;p&gt;报文在不同层，添加不同的首部构成对应协议的数据单元。&lt;/p&gt;
&lt;h2 id=&#34;tcp报文&#34;&gt;TCP报文&lt;/h2&gt;
&lt;p&gt;数据包&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/%E6%95%B0%E6%8D%AE%E5%8C%85.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;IP 数据包在以太网数据包的负载里面，TCP数据包在IP数据包的负载里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/tcp%E9%A6%96%E9%83%A8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;tcp-首部各字段的意义和作用&#34;&gt;TCP 首部各字段的意义和作用&lt;/h5&gt;
&lt;p&gt;TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。&lt;/p&gt;
&lt;h5 id=&#34;源端口和目的端口-port&#34;&gt;源端口和目的端口 Port&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。&lt;/li&gt;
&lt;li&gt;目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 分别占用16位，也就是端口号最大是2^16，所以端口号的范围是0~65536&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;端口号的分配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;知名端口号一般位于：1 --- 255 之间&lt;/li&gt;
&lt;li&gt;256 --- 1023的端口号，通常是由Unix系统占用（系统占用）&lt;/li&gt;
&lt;li&gt;1024 ---5000 是大多数TCP、IP实现的临时分配&lt;/li&gt;
&lt;li&gt;大于5000的一般是给其他服务预留的（Internet上并不常用的服务）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;序号-sequence-number&#34;&gt;序号 Sequence Number&lt;/h5&gt;
&lt;p&gt;TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。&lt;/p&gt;
&lt;h5 id=&#34;确认号-acknowledgemt-number&#34;&gt;确认号 Acknowledgemt Number&lt;/h5&gt;
&lt;p&gt;占 4 个字节，表示期望收到对方下一个报文段的序号值。 TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。&lt;/p&gt;
&lt;p&gt;就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。 例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个确认报文，其中的确认号 = 25600.&lt;/p&gt;
&lt;h5 id=&#34;数据偏移-offset&#34;&gt;数据偏移 Offset&lt;/h5&gt;
&lt;p&gt;占 0.5 个字节 (4 位)。 这个字段实际上是指出了 TCP 报文段的首部长度 ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）&lt;/p&gt;
&lt;p&gt;一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。&lt;/p&gt;
&lt;h5 id=&#34;保留-reserved&#34;&gt;保留 Reserved&lt;/h5&gt;
&lt;p&gt;占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。&lt;/p&gt;
&lt;h5 id=&#34;标志位-tcp-flags&#34;&gt;标志位 TCP Flags&lt;/h5&gt;
&lt;p&gt;标志位，一共有 6 个，分别占 1 位，共 6 位 。 每一位的值只有 0 和 1，分别表达不同意思。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACK：确认序号有效&lt;/li&gt;
&lt;li&gt;RST：重置连接&lt;/li&gt;
&lt;li&gt;SYN：发起了一个新连接&lt;/li&gt;
&lt;li&gt;FIN：释放一个连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;确认-ack-acknowlegemt&#34;&gt;确认 ACK (Acknowlegemt)&lt;/h5&gt;
&lt;p&gt;当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。&lt;/p&gt;
&lt;p&gt;TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。&lt;/p&gt;
&lt;h5 id=&#34;推送-psh-push&#34;&gt;推送 PSH (Push)&lt;/h5&gt;
&lt;p&gt;当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。&lt;/p&gt;
&lt;h5 id=&#34;复位-rst-reset&#34;&gt;复位 RST (Reset)&lt;/h5&gt;
&lt;p&gt;当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。&lt;/p&gt;
&lt;h5 id=&#34;同步-syn-synchronization&#34;&gt;同步 SYN (SYNchronization)&lt;/h5&gt;
&lt;p&gt;当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。&lt;/p&gt;
&lt;p&gt;对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。&lt;/p&gt;
&lt;h5 id=&#34;终止-fin-finis&#34;&gt;终止 FIN (Finis)&lt;/h5&gt;
&lt;p&gt;当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。&lt;/p&gt;
&lt;p&gt;一般称携带 FIN 的报文段为「结束报文段」。&lt;/p&gt;
&lt;p&gt;在 TCP 四次挥手释放连接的时候，就会用到该标志。&lt;/p&gt;
&lt;h5 id=&#34;窗口大小-window-size&#34;&gt;窗口大小 Window Size&lt;/h5&gt;
&lt;p&gt;占 2 字节。&lt;/p&gt;
&lt;p&gt;该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。&lt;/p&gt;
&lt;p&gt;例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。&lt;/p&gt;
&lt;h5 id=&#34;校验和-tcp-checksum&#34;&gt;校验和 TCP Checksum&lt;/h5&gt;
&lt;p&gt;占 2 个字节。 由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。&lt;/p&gt;
&lt;p&gt;检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。&lt;/p&gt;
&lt;h5 id=&#34;紧急指针-urgent-pointer&#34;&gt;紧急指针 Urgent Pointer&lt;/h5&gt;
&lt;p&gt;占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/p&gt;
&lt;p&gt;因此，紧急指针指出了紧急数据的末尾在报文段中的位置。&lt;/p&gt;
&lt;h2 id=&#34;ip数据报&#34;&gt;IP数据报&lt;/h2&gt;
&lt;p&gt;ip数据报分为两部分，首部 和 数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/ip%E6%95%B0%E6%8D%AE%E6%8A%A5.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;IP首部&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/IP%E6%95%B0%E6%8D%AE%E9%A6%96%E9%83%A8.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本&lt;/strong&gt;——占 4 位（第一行四个字节中0~3位），指 IP 协议的版本该 IP 协议的版本号为 4 (即 IPv4)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首部长度&lt;/strong&gt;——占 4 位（第一行四个字节中4~7位），表示首部总的长度（固定+可变部分）；可表示的最大数值是 15 个单位(一个单位为 4 字节)因此 IP 的首部长度的最大值是 60 字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;区分服务&lt;/strong&gt;——占 8 位（第一行四个字节中8~15位），区分服务。即该段设置了数据报的优先程度，若要想实现数据报优先传输还需要在路由器端配置相应的区分服务设置。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总长度&lt;/strong&gt;——占 16 位（第一行四个字节中16~31位），指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标识&lt;/strong&gt;(identification)——占 16 位（第二行四个字节中1~15位），它是一个计数器，用来产生数据报的标识，即每产生一个数据报贴上一个标识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标志&lt;/strong&gt;(flag)——占 3 位（第二行四个字节中16~18位），目前只有前两位有意义。
标志字段的最低位是 &lt;strong&gt;MF&lt;/strong&gt; (More Fragment)。MF = 1 表示后面“还有分片”。&lt;strong&gt;MF&lt;/strong&gt; = 0 表示最后一个分片。
标志字段中间的一位是 &lt;strong&gt;DF&lt;/strong&gt; (Don&#39;t Fragment) 。只有当 DF = 0 时才允许分片。&lt;/p&gt;
&lt;p&gt;即标志表示该数据报是否分片了？是第几个分片？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;片偏移&lt;/strong&gt;——占12 位（第二行四个字节19~31位）指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ip数据报分片&#34;&gt;IP数据报分片：&lt;/h4&gt;
&lt;p&gt;网络链路存在MTU (最大传输单元)—链路层数据帧可封装数据的上限。 不同链路的MTU不同 。&lt;/p&gt;
&lt;p&gt;大IP分组向较小MTU链路转发时， 可以被“分片”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1个IP分组分为多片IP分组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP分片到达目的主机后进行“重组”(reassembled)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/ip%E5%88%86%E7%89%87.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;以太网传输的数据报数据部分一般都是1500个字节。如果有个数据报数据部分为3800字节（数据报总长度超过路由器的对大传送单元&lt;strong&gt;MTU&lt;/strong&gt;） 就需要分为若干个数据报片发送。&lt;/p&gt;
&lt;p&gt;如图中分为三个数据报片发送，在每个数据报片的首部都要写上原数据报首部的信息，包括目标IP 地址等，并编上号。数据报片的数据部分第一个字节表示偏移，每个数据报片的偏移 = 该报片数据部分的第一个字节号 / 8。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生存时间&lt;/strong&gt;——占 8 位（第三行四个字节中0~7位）记为 TTL (Time To Live)数据报在网络中可通过的路由器数的最大值。即计算机发出数据时会附带一个TTL值，该值在数据报每经过一个路由器就自减1，等到某路由器接收到该数据报发现其TTL值变为0时不在中转该数据报，而是将其丢弃并向最初发送者返回一个ICMP报文。TTL的设置可以防止数据报无限循环传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;——占 8 位（第三行四个字节8~15位）字段指出此数据报携带的数据使用何种协议。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;协议号&lt;/th&gt;
&lt;th&gt;协议类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;ICMP&lt;/td&gt;
&lt;td&gt;Internet控制消息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;IGMP&lt;/td&gt;
&lt;td&gt;Internet组管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;传输控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;UDP&lt;/td&gt;
&lt;td&gt;用户数据报&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;首部校验和&lt;/strong&gt;——占 16 位（第三行四个字节16~31位）字段只检验数据报的首部不检验数据部分，目的是验证数据报的首部有无错误。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://draveness.me/whys-the-design-tcp-segment-ip-packet/&#34;&gt;https://draveness.me/whys-the-design-tcp-segment-ip-packet/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/AhuntSun-blog/p/12230694.html&#34;&gt;https://www.cnblogs.com/AhuntSun-blog/p/12230694.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>TCP 问题集合</title>
                <link>https://www.ducksoso.com/posts/network/tcp/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/network/tcp/</guid>
                <pubDate>Thu, 17 Sep 2020 14:33:12 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;流量控制拥塞控制&#34;&gt;流量控制、拥塞控制&lt;/h3&gt;
&lt;h4 id=&#34;一流量控制&#34;&gt;一：流量控制&lt;/h4&gt;
&lt;p&gt;什么是流量控制？流量控制的目的？&lt;/p&gt;
&lt;p&gt;如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。&lt;/p&gt;
&lt;p&gt;如何实现流量控制？&lt;/p&gt;
&lt;p&gt;由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的ACK中会包含自己的接收窗口的大小，并且利用大小来 控制发送方的数据发送。&lt;/p&gt;
&lt;p&gt;流量控制引发的死锁？怎么避免死锁的发生？&lt;/p&gt;
&lt;p&gt;当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
为了避免流量控制引发的死锁，TCP使用了**持续计时器。**每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。&lt;/p&gt;
&lt;h4 id=&#34;二拥塞控制和流量控制区别&#34;&gt;二、拥塞控制和流量控制区别&lt;/h4&gt;
&lt;p&gt;拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。&lt;/p&gt;
&lt;p&gt;流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。&lt;/p&gt;
&lt;h4 id=&#34;三拥塞控制算法&#34;&gt;三、拥塞控制算法&lt;/h4&gt;
&lt;p&gt;四种拥塞控制算法分别是：慢启动，拥塞控制，快重传和快恢复。&lt;/p&gt;
&lt;p&gt;TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。&lt;/p&gt;
&lt;p&gt;发送方需要维护一个叫做拥塞窗口cwnd（congestion window）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。&lt;/p&gt;
&lt;p&gt;为了便于讨论，做如下假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​    接收方有足够大的接收缓存，因此不会发生流量控制；&lt;/li&gt;
&lt;li&gt;​    虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/cwnd.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-慢开始与拥塞避免&#34;&gt;1. 慢开始与拥塞避免&lt;/h4&gt;
&lt;p&gt;发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...&lt;/p&gt;
&lt;p&gt;注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd  增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &amp;gt;=  ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。&lt;/p&gt;
&lt;p&gt;如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。&lt;/p&gt;
&lt;h4 id=&#34;2-快重传与快恢复&#34;&gt;2. 快重传与快恢复&lt;/h4&gt;
&lt;p&gt;在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。&lt;/p&gt;
&lt;p&gt;在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。&lt;/p&gt;
&lt;p&gt;在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。&lt;/p&gt;
&lt;p&gt;慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。&lt;/p&gt;
&lt;h4 id=&#34;3-解决拥塞两条思路&#34;&gt;3. 解决拥塞两条思路：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;增加网络可用资源&lt;/li&gt;
&lt;li&gt;减少用户对资源的需求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真正的发送窗口 = Min（接收方窗口值， 拥塞窗口值）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拥塞的判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重传定时器超时 - 网络已经发生了拥塞。&lt;/p&gt;
&lt;p&gt;接收到三个重复的ACK - 预示网络可能会出现拥塞（实际可能还未发生拥塞）。&lt;/p&gt;
&lt;h3 id=&#34;tcp和udp区别&#34;&gt;TCP和UDP区别&lt;/h3&gt;
&lt;p&gt;它们是 OSI 模型中的传输层中的协议&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP全称为传输控制协议，这种协议可以提供面向连接的、可靠的、点对点的通信，所谓可靠，在于TCP建立连接时双方需要互相确认，类似打电话，在专业术语中称为3次握手。&lt;/p&gt;
&lt;p&gt;UDP全称为用户数据报协议，它可以提供非连接的不可靠的点对多点的通信，所谓不可靠，在于UDP每一次发送数据需要绑定IP和端口号，但是对于已经发送出去的数据来说并不去确认，也不需要类似TCP的三次握手的过程，由于没有了这个过程，所以其传输效率较之TCP来说高很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;TCP&lt;/th&gt;
&lt;th&gt;UDP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;连接性&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;可靠&lt;/td&gt;
&lt;td&gt;不可靠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输内容&lt;/td&gt;
&lt;td&gt;字节流&lt;/td&gt;
&lt;td&gt;报文段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输效率&lt;/td&gt;
&lt;td&gt;一般&lt;/td&gt;
&lt;td&gt;较高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;流量控制&lt;/td&gt;
&lt;td&gt;有（滑动窗口）&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;拥塞控制&lt;/td&gt;
&lt;td&gt;有（慢启动、拥塞避免、快重传和快恢复&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TCP是有缓冲区，UDP面向报文段是没有缓冲区。&lt;/p&gt;
&lt;h5 id=&#34;udp面向报文段tcp面向字节流&#34;&gt;UDP面向报文段，TCP面向字节流&lt;/h5&gt;
&lt;p&gt;​	UDP是面向报文的：发送方的UDP对应用程序交下来的报文，在添加了首部之后就向下交付，UDP对应用层交付下来的报文即不合并也不拆分，而是保留这些报文的边界，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，接收方UDP对下方交上来的UDP用户数据报，在去除首部之后就原封不动的交付给上层的应用程序，一次交付一个完整报文，所以是UDP是面向报文的 。&lt;/p&gt;
&lt;p&gt;​	因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。&lt;/p&gt;
&lt;p&gt;​	TCP是面向字节的：发送方TCP对应用程序交下来的报文数据块，视为无结构的字节流（无边界约束，可拆分/合并），但维持各字节流顺序（相对顺序没有变），TCP发送方有一个发送缓冲区，当应用程序传输的数据块太长，TCP就可以把它划分端一些再传输，如果应用程序一次只传输一个字节，那么TCP可以等待积累足够多的字节后再构成报文端发送出去，所以TCP的面向字节的。&lt;/p&gt;
&lt;h5 id=&#34;tcp无边界udp有边界&#34;&gt;&lt;strong&gt;TCP无边界，UDP有边界&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;TCP无边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UDP有边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp沾包&#34;&gt;TCP沾包&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/6844904083430572046&#34;&gt;https://juejin.im/post/6844904083430572046&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;滑动窗口协议&#34;&gt;滑动窗口协议&lt;/h3&gt;
&lt;p&gt;滑动窗口是针对于发送端和接收端的一种流量控制策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP协议的使用&lt;/li&gt;
&lt;li&gt;维持发送方/接收方缓冲区 缓冲区是 用来解决网络之间数据不可靠的问题，例如丢包，重复包，出错，乱序&lt;/li&gt;
&lt;li&gt;提供TCP可靠性：对发送的数据进行确认&lt;/li&gt;
&lt;li&gt;流量控制：窗口大小随链路变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TCP必需要解决的可靠传输以及包乱序（reordering）的问题&lt;/strong&gt;，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。&lt;/p&gt;
&lt;p&gt;TCP的RTT算法&lt;/p&gt;
&lt;p&gt;RTT(Round Trip Time)往返时间&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://coolshell.cn/articles/11609.html#TCP&#34;&gt;https://coolshell.cn/articles/11609.html#TCP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://coolshell.cn/articles/11609.html#TCP&#34;&gt;https://coolshell.cn/articles/11609.html#TCP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/76023663&#34;&gt;https://zhuanlan.zhihu.com/p/76023663&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jiqizhixin.com/articles/2020-06-01-12&#34;&gt;https://www.jiqizhixin.com/articles/2020-06-01-12&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/ef892323e68f&#34;&gt;https://www.jianshu.com/p/ef892323e68f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://qinnsang.github.io/2019/09/09/TCP%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BF%9E%E6%8E%A5/&#34;&gt;https://qinnsang.github.io/2019/09/09/TCP%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BF%9E%E6%8E%A5/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://my.oschina.net/xinxingegeya/blog/483138&#34;&gt;https://my.oschina.net/xinxingegeya/blog/483138&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/daaikuaichuan/article/details/83061726&#34;&gt;https://blog.csdn.net/daaikuaichuan/article/details/83061726&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Knowledge</title>
                <link>https://www.ducksoso.com/posts/mac/knowledge/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/mac/knowledge/</guid>
                <pubDate>Tue, 15 Sep 2020 17:43:37 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;macos-launchctl-启动进程控制&#34;&gt;MacOS launchctl 启动进程控制&lt;/h3&gt;
&lt;p&gt;MacOS不像 Linux 有 /etc/init.d/rc.local 以及 service 的方式可以设置程序随机启动，而是使用 plist 文件管理。你可以写一个plist文件放到~/Library/Launch Agents/下面，文件里描述你的程序路径和启动参数，那么这个用户登录时就会启动这个程序了，而且是杀不了的哦，被杀了之后会自动重新启动&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;plist文件分布在：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/System/Library/LaunchDaemons/ （System-wide daemons provided by OS X）&lt;/p&gt;
&lt;p&gt;其中 apache的httpd程序启动配置文件 org.apache.httpd.plist 就在这里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/System/Library/LaunchAgents/ （由Mac OS X为用户定义的任务项）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/Library/LaunchDaemons （由管理员定义的守护进程任务项 ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/Library/LaunchAgents （由管理员为用户定义的任务项 ）&lt;/p&gt;
&lt;p&gt;如果放到/Library/Launch Agents/下面的话，就是一开机就启动哦～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;~/Library/LaunchAgents （ 由用户自己定义的任务项 ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些配置文件由程序 &lt;strong&gt;launchctl&lt;/strong&gt; 设置是否加载。&lt;/p&gt;
&lt;p&gt;launchctl 管理 MacOS 的启动脚本，控制启动计算机时需要开启的服务。也可以设置定时执行特定任务的脚本，就像Linux cron一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;launchctl需要root权限。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;launchctl-常用命令&#34;&gt;launchctl 常用命令&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;1.显示当前的启动脚本
launchctl list
 
2.开机时自动启动Apache服务器
sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist
 
3.设置开机启动并立即启动改服务
launchctl load -w   **.pist 
 
4. 设置开机启动但不立即启动服务 
launchctl load **.pist 
 
5. 停止正在运行的启动脚本
sudo launchctl unload &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;path/to/script&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
6. 再加上-w选项即可去除开机启动
sudo launchctl unload -w &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;path/to/script&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;执行定时脚本设置开机启动步骤&#34;&gt;执行定时脚本|设置开机启动步骤&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;1.写执行脚本 （通过 brew 安装软件 brew 会为我们自动生成。）
2. 去对应的目录下建立plist文件 
3. 加载服务
    &amp;gt;1 &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; 进入指定 plist 文件目录 
    &amp;gt;2 launchctl load *.plist &lt;span class=&#34;c1&#34;&gt;#加载&lt;/span&gt; 
       launchctl unload *.plist &lt;span class=&#34;c1&#34;&gt;#取消&lt;/span&gt; 
    &amp;gt;3 launchctl list &lt;span class=&#34;c1&#34;&gt;#查看服务&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;对服务设置别名方便操作&#34;&gt;对服务设置别名方便操作&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;1. vim ~/.bash_profile &lt;span class=&#34;c1&#34;&gt;#编辑添加如下脚本&lt;/span&gt; 
2. 命名别名（以 nginx 为例）
    &amp;gt;启动：alias nginx.start&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;’launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist’ 
    &amp;gt;关闭：alias nginx.stop&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;’launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist’ 
    &amp;gt;重启：alias nginx.restart&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;’nginx.stop &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; nginx.start’
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. 在launchctl list 命令结果中出现的 plist 文件才会有效。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Agents文件夹下的plist是需要用户登录后，才会加载的，而Daemons文件夹下得plist是只要开机，可以不用登录就会被加载&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Makefile</title>
                <link>https://www.ducksoso.com/posts/makefile/makefile/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/makefile/makefile/</guid>
                <pubDate>Mon, 14 Sep 2020 11:13:04 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2015/02/make.html&#34;&gt;https://www.ruanyifeng.com/blog/2015/02/make.html&lt;/a&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Linux命令</title>
                <link>https://www.ducksoso.com/posts/common/linux%E5%91%BD%E4%BB%A4/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/common/linux%E5%91%BD%E4%BB%A4/</guid>
                <pubDate>Sun, 30 Aug 2020 21:37:01 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;1linux-21的意思&#34;&gt;1、Linux 2&amp;gt;&amp;amp;1的意思&lt;/h3&gt;
&lt;p&gt;2&amp;gt;&amp;amp;1的意思是将标准错误(2)也定向到标准输出(1)的输出文件中&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/yanzibuaa/p/7808437.html&#34;&gt;https://www.cnblogs.com/yanzibuaa/p/7808437.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们来具体了解下：Linux 中三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。&lt;/p&gt;
&lt;p&gt;STDIN就是标准输入，默认从键盘读取信息；STDOUT是标准输出，默认将输出结果输出至终端，也就是显示器之类的东西；STDERR是标准的错误信息，默认也会显示在终端上。由于STDOUT与STDERR都会默认显示在终端上，为了区分二者的信息，就有了编号的0，1，2的定义，用1表示STDOUT，2表示STDERR。&lt;/p&gt;
&lt;h4 id=&#34;从commanddevnull说起&#34;&gt;从command&amp;gt;/dev/null说起&lt;/h4&gt;
&lt;p&gt;其实这条命令是一个缩写版，对于一个重定向命令，肯定是&lt;code&gt;a &amp;gt; b&lt;/code&gt;这种形式，那么&lt;code&gt;command &amp;gt; /dev/null&lt;/code&gt;难道是command充当a的角色，/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。所以&lt;code&gt;command &amp;gt; /dev/null&lt;/code&gt;相当于执行了&lt;code&gt;command 1 &amp;gt; /dev/null&lt;/code&gt;。执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。&lt;/p&gt;
&lt;h4 id=&#34;说说21&#34;&gt;说说2&amp;gt;&amp;amp;1&lt;/h4&gt;
&lt;p&gt;通过上面&lt;code&gt;command &amp;gt; /dev/null&lt;/code&gt;等价于&lt;code&gt;command 1 &amp;gt; /dev/null&lt;/code&gt;,那么对于&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;也就好理解了，2就是标准错误，1是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&amp;amp;1而不是1，这里&amp;amp;是什么？这里&lt;code&gt;&amp;amp;&lt;/code&gt;相当于&lt;strong&gt;等效于标准输出&lt;/strong&gt;。这里有点不好理解，先看下面。&lt;/p&gt;
&lt;h4 id=&#34;commanda-2a-与-commanda-21的区别&#34;&gt;command&amp;gt;a 2&amp;gt;a 与 command&amp;gt;a 2&amp;gt;&amp;amp;1的区别&lt;/h4&gt;
&lt;p&gt;通过上面的分析，对于&lt;code&gt;command&amp;gt;a 2&amp;gt;&amp;amp;1&lt;/code&gt;这条命令，等价于&lt;code&gt;command 1&amp;gt;a 2&amp;gt;&amp;amp;1&lt;/code&gt;可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说&lt;code&gt;command 1&amp;gt;a 2&amp;gt;&amp;amp;1&lt;/code&gt;等价于&lt;code&gt;command 1&amp;gt;a 2&amp;gt;a&lt;/code&gt;呢。其实不是，&lt;code&gt;command 1&amp;gt;a 2&amp;gt;&amp;amp;1&lt;/code&gt;与&lt;code&gt;command 1&amp;gt;a 2&amp;gt;a&lt;/code&gt;还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。&lt;code&gt;&amp;amp;1&lt;/code&gt;的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，&lt;code&gt;command 1&amp;gt;a 2&amp;gt;&amp;amp;1&lt;/code&gt;比&lt;code&gt;command 1&amp;gt;a 2&amp;gt;a&lt;/code&gt;的效率更高&lt;/p&gt;
&lt;h4 id=&#34;再思考一下&#34;&gt;再思考一下&lt;/h4&gt;
&lt;p&gt;为什么2&amp;gt;&amp;amp;1 要放在后边呢？ 我的理解是因为2（也就是错误输出）要重定向到&amp;amp;1，也就是标准输出的引用中，也就是标准输出打开的文件中，所以需要现在前面打开1的输出文件。&lt;/p&gt;
&lt;h4 id=&#34;nohup及nohupout&#34;&gt;nohup及nohup.out&lt;/h4&gt;
&lt;p&gt;如果使用nohup执行命令，配合&amp;amp;的使用，则可以不挂断的将命令执行到后台，如果没有指定重定向文件，则输出将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中，实例如下：&lt;/p&gt;
&lt;p&gt;nohup test.log  2&amp;gt;&amp;amp;1 &amp;amp;&lt;/p&gt;
&lt;h3 id=&#34;linux特殊符号大全&#34;&gt;linux特殊符号大全&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/balaamwe/archive/2012/03/15/2397998.html&#34;&gt;https://www.cnblogs.com/balaamwe/archive/2012/03/15/2397998.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在shell中常用的特殊符号罗列如下：&lt;/p&gt;
&lt;p&gt;#  ;  ;;    .    ,    /    \    &#39;string&#39;|    !  $  ${}  $?    $$  $* &amp;quot;string&amp;quot;*   **  ?  :  ^  $#  $@  &lt;code&gt;command&lt;/code&gt;{} []  [[]]  ()  (())  ||  &amp;amp;&amp;amp;    {xx,yy,zz,...}~  ~+  ~-  &amp;amp;  &amp;lt;...&amp;gt;  +    -     %=  ==  !=&lt;/p&gt;
&lt;h3 id=&#34;shell-命令&#34;&gt;shell 命令&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;必须在调用函数地方之前，声明函数，shell脚本是逐行运行。不会像其它语言一样先预编译。&lt;strong&gt;&lt;code&gt;必须在使用函数前先声明函数。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;total=$(fSum 3 2);  通过这种调用方法，我们清楚知道，&lt;strong&gt;&lt;code&gt;在shell 中 单括号里面，可以是：命令语句。&lt;/code&gt;&lt;/strong&gt; 因此，我们可以将Shell中函数，看作是&lt;strong&gt;&lt;code&gt;定义一个新的命令，它是命令，因此 各个输入参数直接用空格分隔。&lt;/code&gt;&lt;/strong&gt; 一次，命令里面获得参数方法可以通过：$0…$n得到。 &lt;strong&gt;&lt;code&gt;$0代表函数本身。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;函数返回值，只能通过$?系统变量获得，直接通过=,获得是空值。&lt;/code&gt;&lt;/strong&gt;其实，我们按照上面一条理解，知道函数是一个命令，在Shell获得命令返回值，都需要通过$?获得。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;vs区别&#34;&gt;${}	vs	$()区别&lt;/h4&gt;
&lt;p&gt;$() 命令替换，会优先执行()中的命令&lt;/p&gt;
&lt;h4 id=&#34;devnull&#34;&gt;&amp;gt;/dev/null&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/53295083&#34;&gt;https://www.zhihu.com/question/53295083&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单地理解就是，重定向操作给这个/dev/null文件的所有东西都会被丢弃。&lt;/p&gt;
&lt;p&gt;/dev/null是一个特殊的设备文件，这个文件接收到的任何数据都会被丢弃。因此，null这个设备通常也被成为位桶（bit bucket）或黑洞。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Gin理解</title>
                <link>https://www.ducksoso.com/posts/interview/gin%E7%90%86%E8%A7%A3/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/interview/gin%E7%90%86%E8%A7%A3/</guid>
                <pubDate>Thu, 20 Aug 2020 10:22:25 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/WechatIMG3434.png&#34; alt=&#34;image-20200820102236793&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Http2优点</title>
                <link>https://www.ducksoso.com/posts/interview/http2/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/interview/http2/</guid>
                <pubDate>Wed, 19 Aug 2020 17:13:53 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h5 id=&#34;http2-相比于-http-1大幅提升了-web-性能减少网络延迟&#34;&gt;HTTP/2 相比于 HTTP 1，大幅提升了 web 性能，减少网络延迟。&lt;/h5&gt;
&lt;p&gt;一、多路复用的单一长连接&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单一长连接
在HTTP/2中，客户端向某个域名的服务器请求页面的过程中，只会创建一条TCP连接，即使这页面可能包含上百个资源。  单一的连接应该是HTTP2的主要优势，单一的连接能减少TCP握手带来的时延 。HTTP2中用一条单一的长连接，避免了创建多个TCP连接带来的网络开销，提高了吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多路复用&lt;/p&gt;
&lt;p&gt;HTTP2虽然只有一条TCP连接，但是在逻辑上分成了很多stream。 HTTP2把要传输的信息分割成一个个二进制帧，首部信息会被封装到HEADER Frame，相应的request body就放到DATA Frame,一个帧你可以看成路上的一辆车,只要给这些车编号，让1号车都走1号门出，2号车都走2号门出，就把不同的http请求或者响应区分开来了。但是，这里要求同一个请求或者响应的帧必须是有有序的，要保证FIFO的，但是不同的请求或者响应帧可以互相穿插。这就是HTTP2的多路复用，是不是充分利用了网络带宽，是不是提高了并发度？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、头部压缩和二进制格式&lt;/p&gt;
&lt;p&gt;http1.x一直都是plain text,对此我只能想到一个优点，便于阅读和debug。但是，现在很多都走https，SSL也把plain text变成了二进制，那这个优点也没了。于是HTTP2搞了个HPACK压缩来压缩头部，减少报文大小(调试这样的协议将需要curl这样的工具，要进一步地分析网络数据流需要类似Wireshark的http2解析器)。&lt;/p&gt;
&lt;p&gt;三、服务端推动Sever Push&lt;/p&gt;
&lt;p&gt;这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。
这个功能帮助客户端将Z放进缓存以备将来之需。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Markdown使用手册</title>
                <link>https://www.ducksoso.com/posts/common/markdown/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/common/markdown/</guid>
                <pubDate>Mon, 17 Aug 2020 10:50:59 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;markdown-使用手册&#34;&gt;Markdown 使用手册&lt;/h3&gt;
&lt;p&gt;1、如何设置字体颜色、大小、字体？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;font face=&amp;quot;黑体&amp;quot; color=red size=12&amp;gt; 红色 &amp;lt;/font&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face=&#34;黑体&#34; color=red size=5&gt; 我是红色 &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;2、 为文字添加背景色&lt;/p&gt;
&lt;p&gt;借助 table、tr、td 等表格标签 bgcolor 属性来实现背景色，故这里对于文字背景色的设置，只是将那一整行看作一个表格，更改了那个格子的背景色（bgcolor）。&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt; 背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;3、设置图片大小&lt;/p&gt;
&lt;p&gt;3.1 设置图片百分比&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;&amp;quot; width=&amp;quot;50%&amp;quot; height=&amp;quot;50%&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.2 设置图片大小&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;&amp;quot; width=&amp;quot;251&amp;quot; height=&amp;quot;350&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.3 设置图片居中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div align=right&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot; width=&amp;quot;50%&amp;quot; height=&amp;quot;50%&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>Mysql-索引</title>
                <link>https://www.ducksoso.com/posts/mysql/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/mysql/</guid>
                <pubDate>Thu, 13 Aug 2020 21:54:04 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h5 id=&#34;1-mysql主键索引和唯一索引的区别&#34;&gt;1. Mysql主键索引和唯一索引的区别?&lt;/h5&gt;
&lt;p&gt;&lt;font color=red&gt;&lt;strong&gt;1.1 主键&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;主键ID，可以一列或多列，主键即是约束也是索引且是唯一索引，同时也用于对象缓存的健值。&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;&lt;strong&gt;1.2 索引&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;组合或者引用关系的子表（数据量较大的时候），需要在关联主表的列上建立非聚集索引（如订单明细表中的产品ID字段、订单明细表中关联的订单ID字段）&lt;/p&gt;
&lt;p&gt;索引键的大小不能超过900个字节，当列表的大小超过900个字节或者若干列的和超过900个字节时，数据库将报错。&lt;/p&gt;
&lt;p&gt;&lt;font color=#ff0000&gt; 表中如果建有大量索引将会影响 INSERT、UPDATE、DELETE 语句的性能 &lt;/font&gt;，因为表中的数据更改时，所有的索引都将必须进行适当的调整。需要避免对经常更新的表进行过多的索引，并且索引应保持较窄，列要尽可能的少。&lt;/p&gt;
&lt;p&gt;为经常用于查询的谓词创建索引，如用于下拉参照快速查找的 code、name等。在平台现有下拉参照的查询sql语句中的like条件语句要改成不带前置通配符，还有需要关注 Order By 和 Group By 谓词的索引设计，Order By 和 Group By 的谓词是需要排序的，某些情况下为 Order By 和 Group By 的谓词建立索引，会避免查询时的排序动作。&lt;/p&gt;
&lt;p&gt;&lt;font color=006eff&gt;对于内容基本重复的列，比如只有0和1，禁止建立索引， &lt;/font&gt;因为该索引选择性极差，在特定的情况下会误导优化器作出错误的选择，导致查询速度极大下降。&lt;/p&gt;
&lt;p&gt;当一个索引有多个列构成时，应注意将选择性强的列放在前面。仅仅前后次序的不同，性能上就可能出现数量级的差异。&lt;/p&gt;
&lt;p&gt;对小表进行索引可能不能产生优化效果，因为查询优化器在遍历用于搜索数据的索引时，花费的时间可能比执行简单的表扫描还长，设计索引时需要考虑表的大小。记录数不大于100的表不要建立索引，频繁操作的小数量表不建议建立索引，例如记录数不大于5000条。&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;&lt;strong&gt;唯一索引与主键索引的比较&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一索引不允许两行具有相同的索引值。&lt;/p&gt;
&lt;p&gt;如果现有数据中存在重复的键值，则大多数数据库都不允许将新创建的唯一索引与表一起保存。当新数据将使表中的键值重复时，数据库也拒绝接受此数据。例如，如果在 employee 表中的职员姓氏（lname）列上创建了唯一索引，则所有职员不能同姓。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主键索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主键索引是唯一索引的特殊类型，其唯一索引名为 primary。&lt;/p&gt;
&lt;p&gt;表的主键，数据库表通常有一列或多列组合，其值用来唯一标识表中的每一行。&lt;/p&gt;
&lt;p&gt;在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。&lt;/p&gt;
&lt;p&gt;二者比较：&lt;/p&gt;
&lt;p&gt;主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于主键/unique constraint , oracle/sql server/mysql等都会自动建立唯一索引；&lt;/li&gt;
&lt;li&gt;主键不一定只包含一个字段，所以在主键的其中一个字段建唯一索引还是必要的；&lt;/li&gt;
&lt;li&gt;主键可作为外键，唯一索引不可；&lt;/li&gt;
&lt;li&gt;主键不可为空，唯一索引可；&lt;/li&gt;
&lt;li&gt;主键也可是多个字段的组合；&lt;/li&gt;
&lt;li&gt;在RBO模式下，主键的执行计划优先级要高于唯一索引；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主键严格于唯一索引体现在：&lt;/p&gt;
&lt;p&gt;a. 主键有 not null 属性&lt;/p&gt;
&lt;p&gt;b. 主键在每个表只能有一个&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;&lt;strong&gt;主键与唯一索引的区别&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;font color=#0001CD&gt;主键一定是唯一索引，其索引名为primary，唯一性索引并不一定是主键&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=#0001CD&gt;一个表中可以有多个唯一性索引，但只能有一个主键&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=#0001CD&gt;主键列不允许空值，而唯一性索引列允许空值&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>LinkList</title>
                <link>https://www.ducksoso.com/posts/algorithm/linklist/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/algorithm/linklist/</guid>
                <pubDate>Thu, 13 Aug 2020 16:33:05 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;单链表反转&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.ducksoso.com/images/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC.jpg&#34; alt=&#34;单链表反转&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>最长上升子序列</title>
                <link>https://www.ducksoso.com/posts/leetcode/300/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/leetcode/300/</guid>
                <pubDate>Thu, 13 Aug 2020 16:19:32 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;方法一：动态规划&lt;/p&gt;
&lt;p&gt;思路：定义dp[i]为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。
我们从小到大计算dp[]数组的值，在计算dp[i]之前，我们已经计算出 dp[0 ... i - 1] 的值，则状态转移
方程为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  dp[i] = max(dp[j]) + 1，其中 0 &amp;lt;= j &amp;lt; i 且 num[j] &amp;lt; num[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即考虑往dp[0 ... i - 1] 中最长的上升子序列后面再加一个 num[i]。由于 dp[j] 代表 nums[0 ... j] 中
以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必须要大于 num[j]，
才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。&lt;/p&gt;
&lt;p&gt;最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LTS_length = max(dp[i]) ， 其中 0 &amp;lt;= i &amp;lt; n&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lengthOfLTS1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nums&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

   &lt;span class=&#34;nx&#34;&gt;dp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;

   &lt;span class=&#34;nx&#34;&gt;maxans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;maxval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;maxval&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maxval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;maxans&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maxans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxans&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
                
                
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://www.ducksoso.com/categories/leetcode/">leetcode</category>
                                
                            
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://www.ducksoso.com/tags/leetcode/">leetcode</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Interface</title>
                <link>https://www.ducksoso.com/posts/interface/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/interface/</guid>
                <pubDate>Thu, 13 Aug 2020 16:02:44 &#43;0800</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/63649977&#34;&gt;https://zhuanlan.zhihu.com/p/63649977&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;1go语言与鸭子的关系&#34;&gt;1、Go语言与鸭子的关系&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;if it looks like a duck, swims like a duck, and quacks like a duck,
then it probably is a duck.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;翻译：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果某个东西长的像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。&lt;/p&gt;
&lt;p&gt;不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。&lt;/p&gt;
&lt;p&gt;小结：鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它“当前方法和属性的集合”决定。Go作为一种静态语言，通过接口实现了&lt;code&gt;鸭子类型&lt;/code&gt;，实际上是Go的编译器在其中做了隐匿的转换工作。&lt;/p&gt;
&lt;p&gt;2、值接收者和指针接收者的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。&lt;/li&gt;
&lt;li&gt;实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面两个不一样，一个是类型，另一个是类型实现了接口中的方法。&lt;/p&gt;
&lt;p&gt;如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://www.ducksoso.com/posts/common/common/</link>
                <guid isPermaLink="true">https://www.ducksoso.com/posts/common/common/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>zzj13865@gmail.com (七八老酒)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;cdn内容分发网络&#34;&gt;CDN（内容分发网络）&lt;/h3&gt;
&lt;p&gt;Content Delivery Network or Content Distribution Network&lt;/p&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。&lt;/p&gt;
&lt;p&gt;目的：&lt;/p&gt;
&lt;p&gt;解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。&lt;/p&gt;
&lt;p&gt;控制时延无疑是现代信息科技的重要指标，CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。&lt;/p&gt;
&lt;p&gt;CDN作用：&lt;/p&gt;
&lt;p&gt;1、加速网站的访问（最主要）- 控制时延&lt;/p&gt;
&lt;p&gt;2、实现跨运营商、跨地域的全网覆盖&lt;/p&gt;
&lt;p&gt;3、为了异地备援&lt;/p&gt;
&lt;p&gt;4、为了节约成本投入&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
    </channel>
</rss>
